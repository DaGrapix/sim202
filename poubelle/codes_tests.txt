vecteur<double> box::force(particle& part, vecteur<double> force_buffer){
    if (this==nullptr){
        return force_buffer;
    }
    if (p_particle != nullptr){
        vecteur<double> force_particle = (G*part.mass*p_particle->mass*(1/pow(norm(part.position - p_particle->position), 3)))*(p_particle->position - part.position);
        force_buffer = force_buffer + force_particle;
        return force_buffer;
    }
    else if (is_in_box(part, *this)){
        force_buffer = p_sub_box->force(part, force_buffer);
        return p_sister_box->force(part, force_buffer);
    }
    else{
        double box_size = LENGTH/pow(2, level);
        double distance = norm(part.position - mass_center);
        if (box_size/distance < THETA){
            vecteur<double> force_box = (G*part.mass*mass*(1/pow(norm(part.position - mass_center), 3)))*(mass_center - part.position);
            force_buffer = force_buffer + force_box;
            return p_sister_box->force(part, force_buffer);
        }
        else{
            return p_sub_box->force(part, force_buffer);
        }
    }
}




void box::pop_particle (particle& part){
    //if the box contains a particles (=> it doesn't have sub_boxes), then we check if it is the particle we want to pop
    if (&part == p_particle){
        p_particle = nullptr;
        mass = 0;
        mass_center = center;
        return;
    }
    if ((p_sub_box==nullptr) && (p_sister_box==nullptr)){
        return;
    }
    //deleting the particle in the sub_boxes
    if (p_sub_box != nullptr){
        box* ptr = p_sub_box;
        while ((not is_in_box(part, *(ptr))) && ptr != nullptr){
            ptr = ptr->p_sister_box;
        }
        //if the pointer is null, that means all of the boxes of this level are empty. Thus we can delete them all.
        if ((ptr == nullptr) && (level!=0)){
            delete p_sub_box;
            p_sub_box = nullptr;
            return;
        }
        else{
            ptr->pop_particle(part);
            //new mass center
            if (mass != part.mass){
                mass_center = (mass*mass_center - part.mass*part.position)/(mass - part.mass);
            }
            else{
                mass_center = center;
            }

            //new mass
            mass = mass - part.mass;

            //we call back the function to delete empty box levels.
            pop_particle(part);
        }
    }
}








/*
//this function returns a N-vector, each component being a 2-vector which is the couple (position, speed) of a particle
vecteur<vecteur<vecteur<double>>> plummer_initialisation (int N, double M, double E){

    vecteur<vecteur<vecteur<double>>> initial_particles=vecteur<vecteur<vecteur<double>>> (N, vecteur<vecteur<double>>(2,vecteur<double>(3,0.0)));

    for (int i=0;i<=N-1;i++){
        //Step 1: calculation of r
        double X1=random_variable();
        double a=pow(X1,-0.666) - 1.0;
        double r=pow(a,-0.5);
        cout<<"a"<<a<<endl;

        //Step 2: Calculation of position coordinates
        double X2=random_variable();
        double X3=random_variable();

        double z=(1 - 2*X2)*r;
        double x=sqrt((r*r - z*z))*cos(2*M_PI*X3);
        double y=(r*r - z*z)*sin(2*M_PI*X3);

        //Step 3: Calculation of V, Ve and g(q)
        double Ve=sqrt(2.0)*pow(1.0 + r*r, -0.25);

        double X4=random_variable();
        double X5=random_variable();

        while(X5 >= 10*g(X4)){
            double X4=random_variable();
            double X5=random_variable();
        }

        double q=X4;

        double V=q*Ve;

        //Step 4: Calculation of speed coordinates
        double X6=random_variable();
        double X7=random_variable();

        double w=(1.0 - 2*X6)*V;
        double u=sqrt((V*V - w*w))*cos(2*M_PI*X7);
        double v=sqrt((V*V - w*w))*sin(2*M_PI*X7);

        //Update of initial_particles
        initial_particles[i][0][0]=x;
        initial_particles[i][0][1]=y;
        initial_particles[i][0][2]=z;

        initial_particles[i][1][0]=u;
        initial_particles[i][1][1]=v;
        initial_particles[i][1][2]=w;
    }
    return initial_particles;
}
*/
/*
int main(){
vecteur<vecteur<vecteur<double>>> res=Plummer_initialisation(3,1,1);
cout<<"initialisation"<<endl<<res<<endl;
}
*/


double random_variable(){
    double x = double(rand()%101); //x in the range 0 to 100, loi uniforme
    x = x/100.0;
    return(x);
}